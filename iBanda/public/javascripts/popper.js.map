{
    version: 3,
    file: "popper.min.js",
    sources: [
    "../../src/utils/isFunction.js",
    "../../src/utils/getStyleComputedProperty.js",
    "../../src/utils/getParentNode.js",
    "../../src/utils/getScrollParent.js",
    "../../src/utils/isIE.js",
    "../../src/utils/getOffsetParent.js",
    "../../src/utils/isOffsetContainer.js",
    "../../src/utils/getRoot.js",
    "../../src/utils/findCommonOffsetParent.js",
    "../../src/utils/getScroll.js",
    "../../src/utils/includeScroll.js",
    "../../src/utils/getBordersSize.js",
    "../../src/utils/getWindowSizes.js",
    "../../src/utils/getClientRect.js",
    "../../src/utils/getBoundingClientRect.js",
    "../../src/utils/getOffsetRectRelativeToArbitraryNode.js",
    "../../src/utils/getViewportOffsetRectRelativeToArtbitraryNode.js",
    "../../src/utils/isFixed.js",
    "../../src/utils/getFixedPositionOffsetParent.js",
    "../../src/utils/getBoundaries.js",
    "../../src/utils/computeAutoPlacement.js",
    "../../src/utils/getReferenceOffsets.js",
    "../../src/utils/getOuterSizes.js",
    "../../src/utils/getOppositePlacement.js",
    "../../src/utils/getPopperOffsets.js",
    "../../src/utils/find.js",
    "../../src/utils/findIndex.js",
    "../../src/utils/runModifiers.js",
    "../../src/methods/update.js",
    "../../src/utils/isModifierEnabled.js",
    "../../src/utils/getSupportedPropertyName.js",
    "../../src/methods/destroy.js",
    "../../src/utils/getWindow.js",
    "../../src/utils/setupEventListeners.js",
    "../../src/methods/enableEventListeners.js",
    "../../src/utils/removeEventListeners.js",
    "../../src/methods/disableEventListeners.js",
    "../../src/utils/isNumeric.js",
    "../../src/utils/setStyles.js",
    "../../src/utils/setAttributes.js",
    "../../src/utils/getRoundedOffsets.js",
    "../../src/utils/isModifierRequired.js",
    "../../src/utils/getOppositeVariation.js",
    "../../src/utils/clockwise.js",
    "../../src/modifiers/offset.js",
    "../../src/utils/debounce.js",
    "../../src/modifiers/arrow.js",
    "../../src/utils/isBrowser.js",
    "../../src/modifiers/computeStyle.js",
    "../../src/modifiers/flip.js",
    "../../src/index.js",
    "../../src/methods/defaults.js",
    "../../src/modifiers/index.js",
    "../../src/modifiers/shift.js",
    "../../src/modifiers/preventOverflow.js",
    "../../src/modifiers/keepTogether.js",
    "../../src/modifiers/inner.js",
    "../../src/modifiers/hide.js",
    "../../src/modifiers/applyStyle.js"
    ],
    sourcesContent: [
    "/** * Check if the given variable is a function * @method * @memberof Popper.Utils * @argument {Any} functionToCheck - variable to check * @returns {Boolean} answer to: is a function? */ export default function isFunction(functionToCheck) { const getType = {}; return ( functionToCheck && getType.toString.call(functionToCheck) === '[object Function]' ); } ",
    "/** * Get CSS computed property of the given element * @method * @memberof Popper.Utils * @argument {Eement} element * @argument {String} property */ export default function getStyleComputedProperty(element, property) { if (element.nodeType !== 1) { return []; } // NOTE: 1 DOM access here const window = element.ownerDocument.defaultView; const css = window.getComputedStyle(element, null); return property ? css[property] : css; } ",
    "/** * Returns the parentNode or the host of the element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} parent */ export default function getParentNode(element) { if (element.nodeName === 'HTML') { return element; } return element.parentNode || element.host; } ",
    "import getStyleComputedProperty from './getStyleComputedProperty'; import getParentNode from './getParentNode'; /** * Returns the scrolling parent of the given element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} scroll parent */ export default function getScrollParent(element) { // Return body, `getScroll` will take care to get the correct `scrollTop` from it if (!element) { return document.body } switch (element.nodeName) { case 'HTML': case 'BODY': return element.ownerDocument.body case '#document': return element.body } // Firefox want us to check `-x` and `-y` variations as well const { overflow, overflowX, overflowY } = getStyleComputedProperty(element); if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) { return element; } return getScrollParent(getParentNode(element)); } ",
    "import isBrowser from './isBrowser'; const isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode); const isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent); /** * Determines if the browser is Internet Explorer * @method * @memberof Popper.Utils * @param {Number} version to check * @returns {Boolean} isIE */ export default function isIE(version) { if (version === 11) { return isIE11; } if (version === 10) { return isIE10; } return isIE11 || isIE10; } ",
    "import getStyleComputedProperty from './getStyleComputedProperty'; import isIE from './isIE'; /** * Returns the offset parent of the given element * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} offset parent */ export default function getOffsetParent(element) { if (!element) { return document.documentElement; } const noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here let offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent while (offsetParent === noOffsetParent && element.nextElementSibling) { offsetParent = (element = element.nextElementSibling).offsetParent; } const nodeName = offsetParent && offsetParent.nodeName; if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') { return element ? element.ownerDocument.documentElement : document.documentElement; } // .offsetParent will return the closest TH, TD or TABLE in case // no offsetParent is present, I hate this job... if ( ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static' ) { return getOffsetParent(offsetParent); } return offsetParent; } ",
    "import getOffsetParent from './getOffsetParent'; export default function isOffsetContainer(element) { const { nodeName } = element; if (nodeName === 'BODY') { return false; } return ( nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element ); } ",
    "/** * Finds the root node (document, shadowDOM root) of the given element * @method * @memberof Popper.Utils * @argument {Element} node * @returns {Element} root node */ export default function getRoot(node) { if (node.parentNode !== null) { return getRoot(node.parentNode); } return node; } ",
    "import isOffsetContainer from './isOffsetContainer'; import getRoot from './getRoot'; import getOffsetParent from './getOffsetParent'; /** * Finds the offset parent common to the two provided nodes * @method * @memberof Popper.Utils * @argument {Element} element1 * @argument {Element} element2 * @returns {Element} common offset parent */ export default function findCommonOffsetParent(element1, element2) { // This check is needed to avoid errors in case one of the elements isn't defined for any reason if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) { return document.documentElement; } // Here we make sure to give as "start" the element that comes first in the DOM const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING; const start = order ? element1 : element2; const end = order ? element2 : element1; // Get common ancestor container const range = document.createRange(); range.setStart(start, 0); range.setEnd(end, 0); const { commonAncestorContainer } = range; // Both nodes are inside #document if ( (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer) || start.contains(end) ) { if (isOffsetContainer(commonAncestorContainer)) { return commonAncestorContainer; } return getOffsetParent(commonAncestorContainer); } // one of the nodes is inside shadowDOM, find which one const element1root = getRoot(element1); if (element1root.host) { return findCommonOffsetParent(element1root.host, element2); } else { return findCommonOffsetParent(element1, getRoot(element2).host); } } ",
    "/** * Gets the scroll value of the given element in the given side (top and left) * @method * @memberof Popper.Utils * @argument {Element} element * @argument {String} side `top` or `left` * @returns {number} amount of scrolled pixels */ export default function getScroll(element, side = 'top') { const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft'; const nodeName = element.nodeName; if (nodeName === 'BODY' || nodeName === 'HTML') { const html = element.ownerDocument.documentElement; const scrollingElement = element.ownerDocument.scrollingElement || html; return scrollingElement[upperSide]; } return element[upperSide]; } ",
    "import getScroll from './getScroll'; /* * Sum or subtract the element scroll values (left and top) from a given rect object * @method * @memberof Popper.Utils * @param {Object} rect - Rect object you want to change * @param {HTMLElement} element - The element from the function reads the scroll values * @param {Boolean} subtract - set to true if you want to subtract the scroll values * @return {Object} rect - The modifier rect object */ export default function includeScroll(rect, element, subtract = false) { const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); const modifier = subtract ? -1 : 1; rect.top += scrollTop * modifier; rect.bottom += scrollTop * modifier; rect.left += scrollLeft * modifier; rect.right += scrollLeft * modifier; return rect; } ",
    "/* * Helper to detect borders of a given element * @method * @memberof Popper.Utils * @param {CSSStyleDeclaration} styles * Result of `getStyleComputedProperty` on the given element * @param {String} axis - `x` or `y` * @return {number} borders - The borders size of the given axis */ export default function getBordersSize(styles, axis) { const sideA = axis === 'x' ? 'Left' : 'Top'; const sideB = sideA === 'Left' ? 'Right' : 'Bottom'; return ( parseFloat(styles[`border${sideA}Width`], 10) + parseFloat(styles[`border${sideB}Width`], 10) ); } ",
    "import isIE from './isIE'; function getSize(axis, body, html, computedStyle) { return Math.max( body[`offset${axis}`], body[`scroll${axis}`], html[`client${axis}`], html[`offset${axis}`], html[`scroll${axis}`], isIE(10) ? (parseInt(html[`offset${axis}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`]) + parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`])) : 0 ); } export default function getWindowSizes(document) { const body = document.body; const html = document.documentElement; const computedStyle = isIE(10) && getComputedStyle(html); return { height: getSize('Height', body, html, computedStyle), width: getSize('Width', body, html, computedStyle), }; } ",
    "/** * Given element offsets, generate an output similar to getBoundingClientRect * @method * @memberof Popper.Utils * @argument {Object} offsets * @returns {Object} ClientRect like output */ export default function getClientRect(offsets) { return { ...offsets, right: offsets.left + offsets.width, bottom: offsets.top + offsets.height, }; } ",
    "import getStyleComputedProperty from './getStyleComputedProperty'; import getBordersSize from './getBordersSize'; import getWindowSizes from './getWindowSizes'; import getScroll from './getScroll'; import getClientRect from './getClientRect'; import isIE from './isIE'; /** * Get bounding client rect of given element * @method * @memberof Popper.Utils * @param {HTMLElement} element * @return {Object} client rect */ export default function getBoundingClientRect(element) { let rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't // considered in DOM in some circumstances... // This isn't reproducible in IE10 compatibility mode of IE11 try { if (isIE(10)) { rect = element.getBoundingClientRect(); const scrollTop = getScroll(element, 'top'); const scrollLeft = getScroll(element, 'left'); rect.top += scrollTop; rect.left += scrollLeft; rect.bottom += scrollTop; rect.right += scrollLeft; } else { rect = element.getBoundingClientRect(); } } catch(e){} const result = { left: rect.left, top: rect.top, width: rect.right - rect.left, height: rect.bottom - rect.top, }; // subtract scrollbar size from sizes const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {}; const width = sizes.width || element.clientWidth || result.right - result.left; const height = sizes.height || element.clientHeight || result.bottom - result.top; let horizScrollbar = element.offsetWidth - width; let vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border` // we make this check conditional for performance reasons if (horizScrollbar || vertScrollbar) { const styles = getStyleComputedProperty(element); horizScrollbar -= getBordersSize(styles, 'x'); vertScrollbar -= getBordersSize(styles, 'y'); result.width -= horizScrollbar; result.height -= vertScrollbar; } return getClientRect(result); } ",
    "import getStyleComputedProperty from './getStyleComputedProperty'; import includeScroll from './includeScroll'; import getScrollParent from './getScrollParent'; import getBoundingClientRect from './getBoundingClientRect'; import runIsIE from './isIE'; import getClientRect from './getClientRect'; export default function getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) { const isIE10 = runIsIE(10); const isHTML = parent.nodeName === 'HTML'; const childrenRect = getBoundingClientRect(children); const parentRect = getBoundingClientRect(parent); const scrollParent = getScrollParent(children); const styles = getStyleComputedProperty(parent); const borderTopWidth = parseFloat(styles.borderTopWidth, 10); const borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); // In cases where the parent is fixed, we must ignore negative scroll in offset calc if(fixedPosition && isHTML) { parentRect.top = Math.max(parentRect.top, 0); parentRect.left = Math.max(parentRect.left, 0); } let offsets = getClientRect({ top: childrenRect.top - parentRect.top - borderTopWidth, left: childrenRect.left - parentRect.left - borderLeftWidth, width: childrenRect.width, height: childrenRect.height, }); offsets.marginTop = 0; offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent // we do this only on HTML because it's the only element that behaves // differently when margins are applied to it. The margins are included in // the box of the documentElement, in the other cases not. if (!isIE10 && isHTML) { const marginTop = parseFloat(styles.marginTop, 10); const marginLeft = parseFloat(styles.marginLeft, 10); offsets.top -= borderTopWidth - marginTop; offsets.bottom -= borderTopWidth - marginTop; offsets.left -= borderLeftWidth - marginLeft; offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them offsets.marginTop = marginTop; offsets.marginLeft = marginLeft; } if ( isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY' ) { offsets = includeScroll(offsets, parent); } return offsets; } ",
    "import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getScroll from './getScroll'; import getClientRect from './getClientRect'; export default function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) { const html = element.ownerDocument.documentElement; const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html); const width = Math.max(html.clientWidth, window.innerWidth || 0); const height = Math.max(html.clientHeight, window.innerHeight || 0); const scrollTop = !excludeScroll ? getScroll(html) : 0; const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0; const offset = { top: scrollTop - relativeOffset.top + relativeOffset.marginTop, left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft, width, height, }; return getClientRect(offset); } ",
    "import getStyleComputedProperty from './getStyleComputedProperty'; import getParentNode from './getParentNode'; /** * Check if the given element is fixed or is inside a fixed parent * @method * @memberof Popper.Utils * @argument {Element} element * @argument {Element} customContainer * @returns {Boolean} answer to "isFixed?" */ export default function isFixed(element) { const nodeName = element.nodeName; if (nodeName === 'BODY' || nodeName === 'HTML') { return false; } if (getStyleComputedProperty(element, 'position') === 'fixed') { return true; } const parentNode = getParentNode(element); if (!parentNode) { return false; } return isFixed(parentNode); } ",
    "import getStyleComputedProperty from './getStyleComputedProperty'; import isIE from './isIE'; /** * Finds the first parent of an element that has a transformed property defined * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Element} first transformed parent or documentElement */ export default function getFixedPositionOffsetParent(element) { // This check is needed to avoid errors in case one of the elements isn't defined for any reason if (!element || !element.parentElement || isIE()) { return document.documentElement; } let el = element.parentElement; while (el && getStyleComputedProperty(el, 'transform') === 'none') { el = el.parentElement; } return el || document.documentElement; } ",
    "import getScrollParent from './getScrollParent'; import getParentNode from './getParentNode'; import findCommonOffsetParent from './findCommonOffsetParent'; import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getViewportOffsetRectRelativeToArtbitraryNode from './getViewportOffsetRectRelativeToArtbitraryNode'; import getWindowSizes from './getWindowSizes'; import isFixed from './isFixed'; import getFixedPositionOffsetParent from './getFixedPositionOffsetParent'; /** * Computed the boundaries limits and return them * @method * @memberof Popper.Utils * @param {HTMLElement} popper * @param {HTMLElement} reference * @param {number} padding * @param {HTMLElement} boundariesElement - Element used to define the boundaries * @param {Boolean} fixedPosition - Is in fixed position mode * @returns {Object} Coordinates of the boundaries */ export default function getBoundaries( popper, reference, padding, boundariesElement, fixedPosition = false ) { // NOTE: 1 DOM access here let boundaries = { top: 0, left: 0 }; const offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); // Handle viewport case if (boundariesElement === 'viewport' ) { boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition); } else { // Handle other cases based on DOM element used as boundaries let boundariesNode; if (boundariesElement === 'scrollParent') { boundariesNode = getScrollParent(getParentNode(reference)); if (boundariesNode.nodeName === 'BODY') { boundariesNode = popper.ownerDocument.documentElement; } } else if (boundariesElement === 'window') { boundariesNode = popper.ownerDocument.documentElement; } else { boundariesNode = boundariesElement; } const offsets = getOffsetRectRelativeToArbitraryNode( boundariesNode, offsetParent, fixedPosition ); // In case of HTML, we need a different computation if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) { const { height, width } = getWindowSizes(popper.ownerDocument); boundaries.top += offsets.top - offsets.marginTop; boundaries.bottom = height + offsets.top; boundaries.left += offsets.left - offsets.marginLeft; boundaries.right = width + offsets.left; } else { // for all the other DOM elements, this one is good boundaries = offsets; } } // Add paddings padding = padding || 0; const isPaddingNumber = typeof padding === 'number'; boundaries.left += isPaddingNumber ? padding : padding.left || 0; boundaries.top += isPaddingNumber ? padding : padding.top || 0; boundaries.right -= isPaddingNumber ? padding : padding.right || 0; boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0; return boundaries; } ",
    "import getBoundaries from '../utils/getBoundaries'; function getArea({ width, height }) { return width * height; } /** * Utility used to transform the `auto` placement to the placement with more * available space. * @method * @memberof Popper.Utils * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function computeAutoPlacement( placement, refRect, popper, reference, boundariesElement, padding = 0 ) { if (placement.indexOf('auto') === -1) { return placement; } const boundaries = getBoundaries( popper, reference, padding, boundariesElement ); const rects = { top: { width: boundaries.width, height: refRect.top - boundaries.top, }, right: { width: boundaries.right - refRect.right, height: boundaries.height, }, bottom: { width: boundaries.width, height: boundaries.bottom - refRect.bottom, }, left: { width: refRect.left - boundaries.left, height: boundaries.height, }, }; const sortedAreas = Object.keys(rects) .map(key => ({ key, ...rects[key], area: getArea(rects[key]), })) .sort((a, b) => b.area - a.area); const filteredAreas = sortedAreas.filter( ({ width, height }) => width >= popper.clientWidth && height >= popper.clientHeight ); const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key; const variation = placement.split('-')[1]; return computedPlacement + (variation ? `-${variation}` : ''); } ",
    "import findCommonOffsetParent from './findCommonOffsetParent'; import getOffsetRectRelativeToArbitraryNode from './getOffsetRectRelativeToArbitraryNode'; import getFixedPositionOffsetParent from './getFixedPositionOffsetParent'; /** * Get offsets to the reference element * @method * @memberof Popper.Utils * @param {Object} state * @param {Element} popper - the popper element * @param {Element} reference - the reference element (the popper will be relative to this) * @param {Element} fixedPosition - is in fixed position mode * @returns {Object} An object containing the offsets which will be applied to the popper */ export default function getReferenceOffsets(state, popper, reference, fixedPosition = null) { const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference); return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition); } ",
    "/** * Get the outer sizes of the given element (offset size + margins) * @method * @memberof Popper.Utils * @argument {Element} element * @returns {Object} object containing width and height properties */ export default function getOuterSizes(element) { const window = element.ownerDocument.defaultView; const styles = window.getComputedStyle(element); const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0); const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0); const result = { width: element.offsetWidth + y, height: element.offsetHeight + x, }; return result; } ",
    "/** * Get the opposite placement of the given one * @method * @memberof Popper.Utils * @argument {String} placement * @returns {String} flipped placement */ export default function getOppositePlacement(placement) { const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; return placement.replace(/left|right|bottom|top/g, matched => hash[matched]); } ",
    "import getOuterSizes from './getOuterSizes'; import getOppositePlacement from './getOppositePlacement'; /** * Get offsets to the popper * @method * @memberof Popper.Utils * @param {Object} position - CSS position the Popper will get applied * @param {HTMLElement} popper - the popper element * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this) * @param {String} placement - one of the valid placement options * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper */ export default function getPopperOffsets(popper, referenceOffsets, placement) { placement = placement.split('-')[0]; // Get popper node sizes const popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object const popperOffsets = { width: popperRect.width, height: popperRect.height, }; // depending by the popper placement we have to compute its offsets slightly differently const isHoriz = ['right', 'left'].indexOf(placement) !== -1; const mainSide = isHoriz ? 'top' : 'left'; const secondarySide = isHoriz ? 'left' : 'top'; const measurement = isHoriz ? 'height' : 'width'; const secondaryMeasurement = !isHoriz ? 'height' : 'width'; popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2; if (placement === secondarySide) { popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement]; } else { popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)]; } return popperOffsets; } ",
    "/** * Mimics the `find` method of Array * @method * @memberof Popper.Utils * @argument {Array} arr * @argument prop * @argument value * @returns index or -1 */ export default function find(arr, check) { // use native find if supported if (Array.prototype.find) { return arr.find(check); } // use `filter` to obtain the same behavior of `find` return arr.filter(check)[0]; } ",
    "import find from './find'; /** * Return the index of the matching object * @method * @memberof Popper.Utils * @argument {Array} arr * @argument prop * @argument value * @returns index or -1 */ export default function findIndex(arr, prop, value) { // use native findIndex if supported if (Array.prototype.findIndex) { return arr.findIndex(cur => cur[prop] === value); } // use `find` + `indexOf` if `findIndex` isn't supported const match = find(arr, obj => obj[prop] === value); return arr.indexOf(match); } ",
    "import isFunction from './isFunction'; import findIndex from './findIndex'; import getClientRect from '../utils/getClientRect'; /** * Loop trough the list of modifiers and run them in order, * each of them will then edit the data object. * @method * @memberof Popper.Utils * @param {dataObject} data * @param {Array} modifiers * @param {String} ends - Optional modifier name used as stopper * @returns {dataObject} */ export default function runModifiers(modifiers, data, ends) { const modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends)); modifiersToRun.forEach(modifier => { if (modifier['function']) { // eslint-disable-line dot-notation console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); } const fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation if (modifier.enabled && isFunction(fn)) { // Add properties to offsets to make them a complete clientRect object // we do this before each modifier to make sure the previous one doesn't // mess with these values data.offsets.popper = getClientRect(data.offsets.popper); data.offsets.reference = getClientRect(data.offsets.reference); data = fn(data, modifier); } }); return data; } ",
    "import computeAutoPlacement from '../utils/computeAutoPlacement'; import getReferenceOffsets from '../utils/getReferenceOffsets'; import getPopperOffsets from '../utils/getPopperOffsets'; import runModifiers from '../utils/runModifiers'; /** * Updates the position of the popper, computing the new offsets and applying * the new style.<br /> * Prefer `scheduleUpdate` over `update` because of performance reasons. * @method * @memberof Popper */ export default function update() { // if popper is destroyed, don't perform any further update if (this.state.isDestroyed) { return; } let data = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: false, offsets: {}, }; // compute reference element offsets data.offsets.reference = getReferenceOffsets( this.state, this.popper, this.reference, this.options.positionFixed ); // compute auto placement, store placement inside the data object, // modifiers will be able to edit `placement` if needed // and refer to originalPlacement to know the original value data.placement = computeAutoPlacement( this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding ); // store the computed placement inside `originalPlacement` data.originalPlacement = data.placement; data.positionFixed = this.options.positionFixed; // compute the popper offsets data.offsets.popper = getPopperOffsets( this.popper, data.offsets.reference, data.placement ); data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback // the other ones will call `onUpdate` callback if (!this.state.isCreated) { this.state.isCreated = true; this.options.onCreate(data); } else { this.options.onUpdate(data); } } ",
    "/** * Helper used to know if the given modifier is enabled. * @method * @memberof Popper.Utils * @returns {Boolean} */ export default function isModifierEnabled(modifiers, modifierName) { return modifiers.some( ({ name, enabled }) => enabled && name === modifierName ); } ",
    "/** * Get the prefixed supported property name * @method * @memberof Popper.Utils * @argument {String} property (camelCase) * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix) */ export default function getSupportedPropertyName(property) { const prefixes = [false, 'ms', 'Webkit', 'Moz', 'O']; const upperProp = property.charAt(0).toUpperCase() + property.slice(1); for (let i = 0; i < prefixes.length; i++) { const prefix = prefixes[i]; const toCheck = prefix ? `${prefix}${upperProp}` : property; if (typeof document.body.style[toCheck] !== 'undefined') { return toCheck; } } return null; } ",
    "import isModifierEnabled from '../utils/isModifierEnabled'; import getSupportedPropertyName from '../utils/getSupportedPropertyName'; /** * Destroys the popper. * @method * @memberof Popper */ export default function destroy() { this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled if (isModifierEnabled(this.modifiers, 'applyStyle')) { this.popper.removeAttribute('x-placement'); this.popper.style.position = ''; this.popper.style.top = ''; this.popper.style.left = ''; this.popper.style.right = ''; this.popper.style.bottom = ''; this.popper.style.willChange = ''; this.popper.style[getSupportedPropertyName('transform')] = ''; } this.disableEventListeners(); // remove the popper if user explicity asked for the deletion on destroy // do not use `remove` because IE11 doesn't support it if (this.options.removeOnDestroy) { this.popper.parentNode.removeChild(this.popper); } return this; } ",
    "/** * Get the window associated with the element * @argument {Element} element * @returns {Window} */ export default function getWindow(element) { const ownerDocument = element.ownerDocument; return ownerDocument ? ownerDocument.defaultView : window; } ",
    "import getScrollParent from './getScrollParent'; import getWindow from './getWindow'; function attachToScrollParents(scrollParent, event, callback, scrollParents) { const isBody = scrollParent.nodeName === 'BODY'; const target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent; target.addEventListener(event, callback, { passive: true }); if (!isBody) { attachToScrollParents( getScrollParent(target.parentNode), event, callback, scrollParents ); } scrollParents.push(target); } /** * Setup needed event listeners used to update the popper position * @method * @memberof Popper.Utils * @private */ export default function setupEventListeners( reference, options, state, updateBound ) { // Resize event listener on window state.updateBound = updateBound; getWindow(reference).addEventListener('resize', state.updateBound, { passive: true }); // Scroll event listener on scroll parents const scrollElement = getScrollParent(reference); attachToScrollParents( scrollElement, 'scroll', state.updateBound, state.scrollParents ); state.scrollElement = scrollElement; state.eventsEnabled = true; return state; } ",
    "import setupEventListeners from '../utils/setupEventListeners'; /** * It will add resize/scroll events and start recalculating * position of the popper element when they are triggered. * @method * @memberof Popper */ export default function enableEventListeners() { if (!this.state.eventsEnabled) { this.state = setupEventListeners( this.reference, this.options, this.state, this.scheduleUpdate ); } } ",
    "import getWindow from './getWindow'; /** * Remove event listeners used to update the popper position * @method * @memberof Popper.Utils * @private */ export default function removeEventListeners(reference, state) { // Remove resize event listener on window getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents state.scrollParents.forEach(target => { target.removeEventListener('scroll', state.updateBound); }); // Reset state state.updateBound = null; state.scrollParents = []; state.scrollElement = null; state.eventsEnabled = false; return state; } ",
    "import removeEventListeners from '../utils/removeEventListeners'; /** * It will remove resize/scroll events and won't recalculate popper position * when they are triggered. It also won't trigger `onUpdate` callback anymore, * unless you call `update` method manually. * @method * @memberof Popper */ export default function disableEventListeners() { if (this.state.eventsEnabled) { cancelAnimationFrame(this.scheduleUpdate); this.state = removeEventListeners(this.reference, this.state); } } ",
    "/** * Tells if a given input is a number * @method * @memberof Popper.Utils * @param {*} input to check * @return {Boolean} */ export default function isNumeric(n) { return n !== '' && !isNaN(parseFloat(n)) && isFinite(n); } ",
    "import isNumeric from './isNumeric'; /** * Set the style to the given popper * @method * @memberof Popper.Utils * @argument {Element} element - Element to apply the style to * @argument {Object} styles * Object with a list of properties and values which will be applied to the element */ export default function setStyles(element, styles) { Object.keys(styles).forEach(prop => { let unit = ''; // add unit if the value is numeric and is one of the following if ( ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop]) ) { unit = 'px'; } element.style[prop] = styles[prop] + unit; }); } ",
    "/** * Set the attributes to the given popper * @method * @memberof Popper.Utils * @argument {Element} element - Element to apply the attributes to * @argument {Object} styles * Object with a list of properties and values which will be applied to the element */ export default function setAttributes(element, attributes) { Object.keys(attributes).forEach(function(prop) { const value = attributes[prop]; if (value !== false) { element.setAttribute(prop, attributes[prop]); } else { element.removeAttribute(prop); } }); } ",
    "/** * @function * @memberof Popper.Utils * @argument {Object} data - The data object generated by `update` method * @argument {Boolean} shouldRound - If the offsets should be rounded at all * @returns {Object} The popper's position offsets rounded * * The tale of pixel-perfect positioning. It's still not 100% perfect, but as * good as it can be within reason. * Discussion here: https://github.com/FezVrasta/popper.js/pull/715 * * Low DPI screens cause a popper to be blurry if not using full pixels (Safari * as well on High DPI screens). * * Firefox prefers no rounding for positioning and does not have blurriness on * high DPI screens. * * Only horizontal placement and left/right values need to be considered. */ export default function getRoundedOffsets(data, shouldRound) { const { popper, reference } = data.offsets; const { round, floor } = Math; const noRound = v => v; const referenceWidth = round(reference.width); const popperWidth = round(popper.width); const isVertical = ['left', 'right'].indexOf(data.placement) !== -1; const isVariation = data.placement.indexOf('-') !== -1; const sameWidthParity = referenceWidth % 2 === popperWidth % 2; const bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1; const horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor; const verticalToInteger = !shouldRound ? noRound : round; return { left: horizontalToInteger( bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left ), top: verticalToInteger(popper.top), bottom: verticalToInteger(popper.bottom), right: horizontalToInteger(popper.right), }; } ",
    "import find from './find'; /** * Helper used to know if the given modifier depends from another one.<br /> * It checks if the needed modifier is listed and enabled. * @method * @memberof Popper.Utils * @param {Array} modifiers - list of modifiers * @param {String} requestingName - name of requesting modifier * @param {String} requestedName - name of requested modifier * @returns {Boolean} */ export default function isModifierRequired( modifiers, requestingName, requestedName ) { const requesting = find(modifiers, ({ name }) => name === requestingName); const isRequired = !!requesting && modifiers.some(modifier => { return ( modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order ); }); if (!isRequired) { const requesting = `\`${requestingName}\``; const requested = `\`${requestedName}\``; console.warn( `${requested} modifier is required by ${requesting} modifier in order to work, be sure to include it before ${requesting}!` ); } return isRequired; } ",
    "/** * Get the opposite placement variation of the given one * @method * @memberof Popper.Utils * @argument {String} placement variation * @returns {String} flipped placement variation */ export default function getOppositeVariation(variation) { if (variation === 'end') { return 'start'; } else if (variation === 'start') { return 'end'; } return variation; } ",
    "import placements from '../methods/placements'; // Get rid of `auto` `auto-start` and `auto-end` const validPlacements = placements.slice(3); /** * Given an initial placement, returns all the subsequent placements * clockwise (or counter-clockwise). * * @method * @memberof Popper.Utils * @argument {String} placement - A valid placement (it accepts variations) * @argument {Boolean} counter - Set to true to walk the placements counterclockwise * @returns {Array} placements including their variations */ export default function clockwise(placement, counter = false) { const index = validPlacements.indexOf(placement); const arr = validPlacements .slice(index + 1) .concat(validPlacements.slice(0, index)); return counter ? arr.reverse() : arr; } ",
    "import isNumeric from '../utils/isNumeric'; import getClientRect from '../utils/getClientRect'; import find from '../utils/find'; /** * Converts a string containing value + unit into a px value number * @function * @memberof {modifiers~offset} * @private * @argument {String} str - Value + unit string * @argument {String} measurement - `height` or `width` * @argument {Object} popperOffsets * @argument {Object} referenceOffsets * @returns {Number|String} * Value in pixels, or original string if no values were extracted */ export function toValue(str, measurement, popperOffsets, referenceOffsets) { // separate value from unit const split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/); const value = +split[1]; const unit = split[2]; // If it's not a number it's an operator, I guess if (!value) { return str; } if (unit.indexOf('%') === 0) { let element; switch (unit) { case '%p': element = popperOffsets; break; case '%': case '%r': default: element = referenceOffsets; } const rect = getClientRect(element); return rect[measurement] / 100 * value; } else if (unit === 'vh' || unit === 'vw') { // if is a vh or vw, we calculate the size based on the viewport let size; if (unit === 'vh') { size = Math.max( document.documentElement.clientHeight, window.innerHeight || 0 ); } else { size = Math.max( document.documentElement.clientWidth, window.innerWidth || 0 ); } return size / 100 * value; } else { // if is an explicit pixel unit, we get rid of the unit and keep the value // if is an implicit unit, it's px, and we return just the value return value; } } /** * Parse an `offset` string to extrapolate `x` and `y` numeric offsets. * @function * @memberof {modifiers~offset} * @private * @argument {String} offset * @argument {Object} popperOffsets * @argument {Object} referenceOffsets * @argument {String} basePlacement * @returns {Array} a two cells array with x and y offsets in numbers */ export function parseOffset( offset, popperOffsets, referenceOffsets, basePlacement ) { const offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width // in this way the first offset will use an axis and the second one // will use the other one const useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands // The regex addresses values with the plus or minus sign in front (+10, -20, etc) const fragments = offset.split(/(\+|\-)/).map(frag => frag.trim()); // Detect if the offset string contains a pair of values or a single one // they could be separated by comma or space const divider = fragments.indexOf( find(fragments, frag => frag.search(/,|\s/) !== -1) ); if (fragments[divider] && fragments[divider].indexOf(',') === -1) { console.warn( 'Offsets separated by white space(s) are deprecated, use a comma (,) instead.' ); } // If divider is found, we divide the list of values and operands to divide // them by ofset X and Y. const splitRegex = /\s*,\s*|\s+/; let ops = divider !== -1 ? [ fragments .slice(0, divider) .concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat( fragments.slice(divider + 1) ), ] : [fragments]; // Convert the values with units to absolute pixels to allow our computations ops = ops.map((op, index) => { // Most of the units rely on the orientation of the popper const measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width'; let mergeWithPrevious = false; return ( op // This aggregates any `+` or `-` sign that aren't considered operators // e.g.: 10 + +5 => [10, +, +5] .reduce((a, b) => { if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) { a[a.length - 1] = b; mergeWithPrevious = true; return a; } else if (mergeWithPrevious) { a[a.length - 1] += b; mergeWithPrevious = false; return a; } else { return a.concat(b); } }, []) // Here we convert the string values into number values (in px) .map(str => toValue(str, measurement, popperOffsets, referenceOffsets)) ); }); // Loop trough the offsets arrays and execute the operations ops.forEach((op, index) => { op.forEach((frag, index2) => { if (isNumeric(frag)) { offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1); } }); }); return offsets; } /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @argument {Number|String} options.offset=0 * The offset value as described in the modifier description * @returns {Object} The data object, properly modified */ export default function offset(data, { offset }) { const { placement, offsets: { popper, reference } } = data; const basePlacement = placement.split('-')[0]; let offsets; if (isNumeric(+offset)) { offsets = [+offset, 0]; } else { offsets = parseOffset(offset, popper, reference, basePlacement); } if (basePlacement === 'left') { popper.top += offsets[0]; popper.left -= offsets[1]; } else if (basePlacement === 'right') { popper.top += offsets[0]; popper.left += offsets[1]; } else if (basePlacement === 'top') { popper.left += offsets[0]; popper.top -= offsets[1]; } else if (basePlacement === 'bottom') { popper.left += offsets[0]; popper.top += offsets[1]; } data.popper = popper; return data; } ",
    "import isBrowser from './isBrowser'; const longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox']; let timeoutDuration = 0; for (let i = 0; i < longerTimeoutBrowsers.length; i += 1) { if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) { timeoutDuration = 1; break; } } export function microtaskDebounce(fn) { let called = false return () => { if (called) { return } called = true window.Promise.resolve().then(() => { called = false fn() }) } } export function taskDebounce(fn) { let scheduled = false; return () => { if (!scheduled) { scheduled = true; setTimeout(() => { scheduled = false; fn(); }, timeoutDuration); } }; } const supportsMicroTasks = isBrowser && window.Promise /** * Create a debounced version of a method, that's asynchronously deferred * but called in the minimum time possible. * * @method * @memberof Popper.Utils * @argument {Function} fn * @returns {Function} */ export default (supportsMicroTasks ? microtaskDebounce : taskDebounce); ",
    "import getClientRect from '../utils/getClientRect'; import getOuterSizes from '../utils/getOuterSizes'; import isModifierRequired from '../utils/isModifierRequired'; import getStyleComputedProperty from '../utils/getStyleComputedProperty'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function arrow(data, options) { // arrow depends on keepTogether in order to work if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) { return data; } let arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector if (typeof arrowElement === 'string') { arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier if (!arrowElement) { return data; } } else { // if the arrowElement isn't a query selector we must check that the // provided DOM node is child of its popper node if (!data.instance.popper.contains(arrowElement)) { console.warn( 'WARNING: `arrow.element` must be child of its popper element!' ); return data; } } const placement = data.placement.split('-')[0]; const { popper, reference } = data.offsets; const isVertical = ['left', 'right'].indexOf(placement) !== -1; const len = isVertical ? 'height' : 'width'; const sideCapitalized = isVertical ? 'Top' : 'Left'; const side = sideCapitalized.toLowerCase(); const altSide = isVertical ? 'left' : 'top'; const opSide = isVertical ? 'bottom' : 'right'; const arrowElementSize = getOuterSizes(arrowElement)[len]; // // extends keepTogether behavior making sure the popper and its // reference have enough pixels in conjunction // // top/left side if (reference[opSide] - arrowElementSize < popper[side]) { data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize); } // bottom/right side if (reference[side] + arrowElementSize > popper[opSide]) { data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]; } data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper const center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets // take popper margin in account because we don't have this info available const css = getStyleComputedProperty(data.instance.popper); const popperMarginSide = parseFloat(css[`margin${sideCapitalized}`], 10); const popperBorderSide = parseFloat(css[`border${sideCapitalized}Width`], 10); let sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0); data.arrowElement = arrowElement; data.offsets.arrow = { [side]: Math.round(sideValue), [altSide]: '', // make sure to unset any eventual altSide value from the DOM node }; return data; } ",
    "export default typeof window !== 'undefined' && typeof document !== 'undefined'; ",
    "import getSupportedPropertyName from '../utils/getSupportedPropertyName'; import find from '../utils/find'; import getOffsetParent from '../utils/getOffsetParent'; import getBoundingClientRect from '../utils/getBoundingClientRect'; import getRoundedOffsets from '../utils/getRoundedOffsets'; import isBrowser from '../utils/isBrowser'; const isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent); /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function computeStyle(data, options) { const { x, y } = options; const { popper } = data.offsets; // Remove this legacy support in Popper.js v2 const legacyGpuAccelerationOption = find( data.instance.modifiers, modifier => modifier.name === 'applyStyle' ).gpuAcceleration; if (legacyGpuAccelerationOption !== undefined) { console.warn( 'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!' ); } const gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration; const offsetParent = getOffsetParent(data.instance.popper); const offsetParentRect = getBoundingClientRect(offsetParent); // Styles const styles = { position: popper.position, }; const offsets = getRoundedOffsets( data, window.devicePixelRatio < 2 || !isFirefox ); const sideA = x === 'bottom' ? 'top' : 'bottom'; const sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported, // we use `translate3d` to apply the position to the popper we // automatically use the supported prefixed version if needed const prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?) // If the content of the popper grows once it's been positioned, it // may happen that the popper gets misplaced because of the new content // overflowing its reference element // To avoid this problem, we provide two options (x and y), which allow // the consumer to define the offset origin. // If we position a popper on top of a reference element, we can set // `x` to `top` to make the popper grow towards its top instead of // its bottom. let left, top; if (sideA === 'bottom') { // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar) // and not the bottom of the html element if (offsetParent.nodeName === 'HTML') { top = -offsetParent.clientHeight + offsets.bottom; } else { top = -offsetParentRect.height + offsets.bottom; } } else { top = offsets.top; } if (sideB === 'right') { if (offsetParent.nodeName === 'HTML') { left = -offsetParent.clientWidth + offsets.right; } else { left = -offsetParentRect.width + offsets.right; } } else { left = offsets.left; } if (gpuAcceleration && prefixedProperty) { styles[prefixedProperty] = `translate3d(${left}px, ${top}px, 0)`; styles[sideA] = 0; styles[sideB] = 0; styles.willChange = 'transform'; } else { // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties const invertTop = sideA === 'bottom' ? -1 : 1; const invertLeft = sideB === 'right' ? -1 : 1; styles[sideA] = top * invertTop; styles[sideB] = left * invertLeft; styles.willChange = `${sideA}, ${sideB}`; } // Attributes const attributes = { 'x-placement': data.placement, }; // Update `data` attributes, styles and arrowStyles data.attributes = { ...attributes, ...data.attributes }; data.styles = { ...styles, ...data.styles }; data.arrowStyles = { ...data.offsets.arrow, ...data.arrowStyles }; return data; } ",
    "import getOppositePlacement from '../utils/getOppositePlacement'; import getOppositeVariation from '../utils/getOppositeVariation'; import getPopperOffsets from '../utils/getPopperOffsets'; import runModifiers from '../utils/runModifiers'; import getBoundaries from '../utils/getBoundaries'; import isModifierEnabled from '../utils/isModifierEnabled'; import clockwise from '../utils/clockwise'; const BEHAVIORS = { FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise', }; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function flip(data, options) { // if `inner` modifier is enabled, we can't use the `flip` modifier if (isModifierEnabled(data.instance.modifiers, 'inner')) { return data; } if (data.flipped && data.placement === data.originalPlacement) { // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides return data; } const boundaries = getBoundaries( data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed ); let placement = data.placement.split('-')[0]; let placementOpposite = getOppositePlacement(placement); let variation = data.placement.split('-')[1] || ''; let flipOrder = []; switch (options.behavior) { case BEHAVIORS.FLIP: flipOrder = [placement, placementOpposite]; break; case BEHAVIORS.CLOCKWISE: flipOrder = clockwise(placement); break; case BEHAVIORS.COUNTERCLOCKWISE: flipOrder = clockwise(placement, true); break; default: flipOrder = options.behavior; } flipOrder.forEach((step, index) => { if (placement !== step || flipOrder.length === index + 1) { return data; } placement = data.placement.split('-')[0]; placementOpposite = getOppositePlacement(placement); const popperOffsets = data.offsets.popper; const refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here const floor = Math.floor; const overlapsRef = (placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left)) || (placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right)) || (placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top)) || (placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom)); const overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left); const overflowsRight = floor(popperOffsets.right) > floor(boundaries.right); const overflowsTop = floor(popperOffsets.top) < floor(boundaries.top); const overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom); const overflowsBoundaries = (placement === 'left' && overflowsLeft) || (placement === 'right' && overflowsRight) || (placement === 'top' && overflowsTop) || (placement === 'bottom' && overflowsBottom); // flip the variation if required const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; const flippedVariation = !!options.flipVariations && ((isVertical && variation === 'start' && overflowsLeft) || (isVertical && variation === 'end' && overflowsRight) || (!isVertical && variation === 'start' && overflowsTop) || (!isVertical && variation === 'end' && overflowsBottom)); if (overlapsRef || overflowsBoundaries || flippedVariation) { // this boolean to detect any flip loop data.flipped = true; if (overlapsRef || overflowsBoundaries) { placement = flipOrder[index + 1]; } if (flippedVariation) { variation = getOppositeVariation(variation); } data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with // any additional property we may add in the future data.offsets.popper = { ...data.offsets.popper, ...getPopperOffsets( data.instance.popper, data.offsets.reference, data.placement ), }; data = runModifiers(data.instance.modifiers, data, 'flip'); } }); return data; } ",
    "// Utils import debounce from './utils/debounce'; import isFunction from './utils/isFunction'; // Methods import update from './methods/update'; import destroy from './methods/destroy'; import enableEventListeners from './methods/enableEventListeners'; import disableEventListeners from './methods/disableEventListeners'; import Defaults from './methods/defaults'; import placements from './methods/placements'; export default class Popper { /** * Creates a new Popper.js instance. * @class Popper * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper * @param {HTMLElement} popper - The HTML element used as the popper * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults) * @return {Object} instance - The generated Popper.js instance */ constructor(reference, popper, options = {}) { // make update() debounced, so that it only runs at most once-per-tick this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it this.options = { ...Popper.Defaults, ...options }; // init state this.state = { isDestroyed: false, isCreated: false, scrollParents: [], }; // get reference and popper elements (allow jQuery wrappers) this.reference = reference && reference.jquery ? reference[0] : reference; this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options this.options.modifiers = {}; Object.keys({ ...Popper.Defaults.modifiers, ...options.modifiers, }).forEach(name => { this.options.modifiers[name] = { // If it's a built-in modifier, use it as base ...(Popper.Defaults.modifiers[name] || {}), // If there are custom options, override and merge with default ones ...(options.modifiers ? options.modifiers[name] : {}), }; }); // Refactoring modifiers' list (Object => Array) this.modifiers = Object.keys(this.options.modifiers) .map(name => ({ name, ...this.options.modifiers[name], })) // sort the modifiers by order .sort((a, b) => a.order - b.order); // modifiers have the ability to execute arbitrary code when Popper.js get inited // such code is executed in the same order of its modifier // they could add new properties to their options configuration // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`! this.modifiers.forEach(modifierOptions => { if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) { modifierOptions.onLoad( this.reference, this.popper, this.options, modifierOptions, this.state ); } }); // fire the first update to position the popper in the right place this.update(); const eventsEnabled = this.options.eventsEnabled; if (eventsEnabled) { // setup event listeners, they will take care of update the position in specific situations this.enableEventListeners(); } this.state.eventsEnabled = eventsEnabled; } // We can't use class properties because they don't get listed in the // class prototype and break stuff like Sinon stubs update() { return update.call(this); } destroy() { return destroy.call(this); } enableEventListeners() { return enableEventListeners.call(this); } disableEventListeners() { return disableEventListeners.call(this); } /** * Schedules an update. It will run on the next UI update available. * @method scheduleUpdate * @memberof Popper */ scheduleUpdate = () => requestAnimationFrame(this.update); /** * Collection of utilities useful when writing custom modifiers. * Starting from version 1.7, this method is available only if you * include `popper-utils.js` before `popper.js`. * * **DEPRECATION**: This way to access PopperUtils is deprecated * and will be removed in v2! Use the PopperUtils module directly instead. * Due to the high instability of the methods contained in Utils, we can't * guarantee them to follow semver. Use them at your own risk! * @static * @private * @type {Object} * @deprecated since version 1.8 * @member Utils * @memberof Popper */ static Utils = (typeof window !== 'undefined' ? window : global).PopperUtils; static placements = placements; static Defaults = Defaults; } /** * The `referenceObject` is an object that provides an interface compatible with Popper.js * and lets you use it as replacement of a real DOM node.<br /> * You can use this method to position a popper relatively to a set of coordinates * in case you don't have a DOM node to use as reference. * * ``` * new Popper(referenceObject, popperNode); * ``` * * NB: This feature isn't supported in Internet Explorer 10. * @name referenceObject * @property {Function} data.getBoundingClientRect * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method. * @property {number} data.clientWidth * An ES6 getter that will return the width of the virtual reference element. * @property {number} data.clientHeight * An ES6 getter that will return the height of the virtual reference element. */ ",
    "import modifiers from '../modifiers/index'; /** * Default options provided to Popper.js constructor.<br /> * These can be overridden using the `options` argument of Popper.js.<br /> * To override an option, simply pass an object with the same * structure of the `options` object, as the 3rd argument. For example: * ``` * new Popper(ref, pop, { * modifiers: { * preventOverflow: { enabled: false } * } * }) * ``` * @type {Object} * @static * @memberof Popper */ export default { /** * Popper's placement. * @prop {Popper.placements} placement='bottom' */ placement: 'bottom', /** * Set this to true if you want popper to position it self in 'fixed' mode * @prop {Boolean} positionFixed=false */ positionFixed: false, /** * Whether events (resize, scroll) are initially enabled. * @prop {Boolean} eventsEnabled=true */ eventsEnabled: true, /** * Set to true if you want to automatically remove the popper when * you call the `destroy` method. * @prop {Boolean} removeOnDestroy=false */ removeOnDestroy: false, /** * Callback called when the popper is created.<br /> * By default, it is set to no-op.<br /> * Access Popper.js instance with `data.instance`. * @prop {onCreate} */ onCreate: () => {}, /** * Callback called when the popper is updated. This callback is not called * on the initialization/creation of the popper, but only on subsequent * updates.<br /> * By default, it is set to no-op.<br /> * Access Popper.js instance with `data.instance`. * @prop {onUpdate} */ onUpdate: () => {}, /** * List of modifiers used to modify the offsets before they are applied to the popper. * They provide most of the functionalities of Popper.js. * @prop {modifiers} */ modifiers, }; /** * @callback onCreate * @param {dataObject} data */ /** * @callback onUpdate * @param {dataObject} data */ ",
    "import applyStyle, { applyStyleOnLoad } from './applyStyle'; import computeStyle from './computeStyle'; import arrow from './arrow'; import flip from './flip'; import keepTogether from './keepTogether'; import offset from './offset'; import preventOverflow from './preventOverflow'; import shift from './shift'; import hide from './hide'; import inner from './inner'; /** * Modifier function, each modifier can have a function of this type assigned * to its `fn` property.<br /> * These functions will be called on each update, this means that you must * make sure they are performant enough to avoid performance bottlenecks. * * @function ModifierFn * @argument {dataObject} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {dataObject} The data object, properly modified */ /** * Modifiers are plugins used to alter the behavior of your poppers.<br /> * Popper.js uses a set of 9 modifiers to provide all the basic functionalities * needed by the library. * * Usually you don't want to override the `order`, `fn` and `onLoad` props. * All the other properties are configurations that could be tweaked. * @namespace modifiers */ export default { /** * Modifier used to shift the popper on the start or end of its reference * element.<br /> * It will read the variation of the `placement` property.<br /> * It can be one either `-end` or `-start`. * @memberof modifiers * @inner */ shift: { /** @prop {number} order=100 - Index used to define the order of execution */ order: 100, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: shift, }, /** * The `offset` modifier can shift your popper on both its axis. * * It accepts the following units: * - `px` or unit-less, interpreted as pixels * - `%` or `%r`, percentage relative to the length of the reference element * - `%p`, percentage relative to the length of the popper element * - `vw`, CSS viewport width unit * - `vh`, CSS viewport height unit * * For length is intended the main axis relative to the placement of the popper.<br /> * This means that if the placement is `top` or `bottom`, the length will be the * `width`. In case of `left` or `right`, it will be the `height`. * * You can provide a single value (as `Number` or `String`), or a pair of values * as `String` divided by a comma or one (or more) white spaces.<br /> * The latter is a deprecated method because it leads to confusion and will be * removed in v2.<br /> * Additionally, it accepts additions and subtractions between different units. * Note that multiplications and divisions aren't supported. * * Valid examples are: * ``` * 10 * '10%' * '10, 10' * '10%, 10' * '10 + 10%' * '10 - 5vh + 3%' * '-10px + 5vh, 5px - 6%' * ``` * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap * > with their reference element, unfortunately, you will have to disable the `flip` modifier. * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373). * * @memberof modifiers * @inner */ offset: { /** @prop {number} order=200 - Index used to define the order of execution */ order: 200, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: offset, /** @prop {Number|String} offset=0 * The offset value as described in the modifier description */ offset: 0, }, /** * Modifier used to prevent the popper from being positioned outside the boundary. * * A scenario exists where the reference itself is not within the boundaries.<br /> * We can say it has "escaped the boundaries" — or just "escaped".<br /> * In this case we need to decide whether the popper should either: * * - detach from the reference and remain "trapped" in the boundaries, or * - if it should ignore the boundary and "escape with its reference" * * When `escapeWithReference` is set to`true` and reference is completely * outside its boundaries, the popper will overflow (or completely leave) * the boundaries in order to remain attached to the edge of the reference. * * @memberof modifiers * @inner */ preventOverflow: { /** @prop {number} order=300 - Index used to define the order of execution */ order: 300, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: preventOverflow, /** * @prop {Array} [priority=['left','right','top','bottom']] * Popper will try to prevent overflow following these priorities by default, * then, it could overflow on the left and on top of the `boundariesElement` */ priority: ['left', 'right', 'top', 'bottom'], /** * @prop {number} padding=5 * Amount of pixel used to define a minimum distance between the boundaries * and the popper. This makes sure the popper always has a little padding * between the edges of its container */ padding: 5, /** * @prop {String|HTMLElement} boundariesElement='scrollParent' * Boundaries used by the modifier. Can be `scrollParent`, `window`, * `viewport` or any DOM element. */ boundariesElement: 'scrollParent', }, /** * Modifier used to make sure the reference and its popper stay near each other * without leaving any gap between the two. Especially useful when the arrow is * enabled and you want to ensure that it points to its reference element. * It cares only about the first axis. You can still have poppers with margin * between the popper and its reference element. * @memberof modifiers * @inner */ keepTogether: { /** @prop {number} order=400 - Index used to define the order of execution */ order: 400, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: keepTogether, }, /** * This modifier is used to move the `arrowElement` of the popper to make * sure it is positioned between the reference element and its popper element. * It will read the outer size of the `arrowElement` node to detect how many * pixels of conjunction are needed. * * It has no effect if no `arrowElement` is provided. * @memberof modifiers * @inner */ arrow: { /** @prop {number} order=500 - Index used to define the order of execution */ order: 500, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: arrow, /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */ element: '[x-arrow]', }, /** * Modifier used to flip the popper's placement when it starts to overlap its * reference element. * * Requires the `preventOverflow` modifier before it in order to work. * * **NOTE:** this modifier will interrupt the current update cycle and will * restart it if it detects the need to flip the placement. * @memberof modifiers * @inner */ flip: { /** @prop {number} order=600 - Index used to define the order of execution */ order: 600, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: flip, /** * @prop {String|Array} behavior='flip' * The behavior used to change the popper's placement. It can be one of * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid * placements (with optional variations) */ behavior: 'flip', /** * @prop {number} padding=5 * The popper will flip if it hits the edges of the `boundariesElement` */ padding: 5, /** * @prop {String|HTMLElement} boundariesElement='viewport' * The element which will define the boundaries of the popper position. * The popper will never be placed outside of the defined boundaries * (except if `keepTogether` is enabled) */ boundariesElement: 'viewport', }, /** * Modifier used to make the popper flow toward the inner of the reference element. * By default, when this modifier is disabled, the popper will be placed outside * the reference element. * @memberof modifiers * @inner */ inner: { /** @prop {number} order=700 - Index used to define the order of execution */ order: 700, /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */ enabled: false, /** @prop {ModifierFn} */ fn: inner, }, /** * Modifier used to hide the popper when its reference element is outside of the * popper boundaries. It will set a `x-out-of-boundaries` attribute which can * be used to hide with a CSS selector the popper when its reference is * out of boundaries. * * Requires the `preventOverflow` modifier before it in order to work. * @memberof modifiers * @inner */ hide: { /** @prop {number} order=800 - Index used to define the order of execution */ order: 800, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: hide, }, /** * Computes the style that will be applied to the popper element to gets * properly positioned. * * Note that this modifier will not touch the DOM, it just prepares the styles * so that `applyStyle` modifier can apply it. This separation is useful * in case you need to replace `applyStyle` with a custom implementation. * * This modifier has `850` as `order` value to maintain backward compatibility * with previous versions of Popper.js. Expect the modifiers ordering method * to change in future major versions of the library. * * @memberof modifiers * @inner */ computeStyle: { /** @prop {number} order=850 - Index used to define the order of execution */ order: 850, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: computeStyle, /** * @prop {Boolean} gpuAcceleration=true * If true, it uses the CSS 3D transformation to position the popper. * Otherwise, it will use the `top` and `left` properties */ gpuAcceleration: true, /** * @prop {string} [x='bottom'] * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin. * Change this if your popper should grow in a direction different from `bottom` */ x: 'bottom', /** * @prop {string} [x='left'] * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin. * Change this if your popper should grow in a direction different from `right` */ y: 'right', }, /** * Applies the computed styles to the popper element. * * All the DOM manipulations are limited to this modifier. This is useful in case * you want to integrate Popper.js inside a framework or view library and you * want to delegate all the DOM manipulations to it. * * Note that if you disable this modifier, you must make sure the popper element * has its position set to `absolute` before Popper.js can do its work! * * Just disable this modifier and define your own to achieve the desired effect. * * @memberof modifiers * @inner */ applyStyle: { /** @prop {number} order=900 - Index used to define the order of execution */ order: 900, /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true, /** @prop {ModifierFn} */ fn: applyStyle, /** @prop {Function} */ onLoad: applyStyleOnLoad, /** * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier * @prop {Boolean} gpuAcceleration=true * If true, it uses the CSS 3D transformation to position the popper. * Otherwise, it will use the `top` and `left` properties */ gpuAcceleration: undefined, }, }; /** * The `dataObject` is an object containing all the information used by Popper.js. * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks. * @name dataObject * @property {Object} data.instance The Popper.js instance * @property {String} data.placement Placement applied to popper * @property {String} data.originalPlacement Placement originally defined on init * @property {Boolean} data.flipped True if popper has been flipped by flip modifier * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`) * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`) * @property {Object} data.boundaries Offsets of the popper boundaries * @property {Object} data.offsets The measurements of popper, reference and arrow elements * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0 */ ",
    "/** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function shift(data) { const placement = data.placement; const basePlacement = placement.split('-')[0]; const shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier if (shiftvariation) { const { reference, popper } = data.offsets; const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1; const side = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; const shiftOffsets = { start: { [side]: reference[side] }, end: { [side]: reference[side] + reference[measurement] - popper[measurement], }, }; data.offsets.popper = { ...popper, ...shiftOffsets[shiftvariation] }; } return data; } ",
    "import getOffsetParent from '../utils/getOffsetParent'; import getBoundaries from '../utils/getBoundaries'; import getSupportedPropertyName from '../utils/getSupportedPropertyName'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function preventOverflow(data, options) { let boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to // go one step up and use the next offsetParent as reference to // avoid to make this modifier completely useless and look like broken if (data.instance.reference === boundariesElement) { boundariesElement = getOffsetParent(boundariesElement); } // NOTE: DOM access here // resets the popper's position so that the document size can be calculated excluding // the size of the popper element itself const transformProp = getSupportedPropertyName('transform'); const popperStyles = data.instance.popper.style; // assignment to help minification const { top, left, [transformProp]: transform } = popperStyles; popperStyles.top = ''; popperStyles.left = ''; popperStyles[transformProp] = ''; const boundaries = getBoundaries( data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed ); // NOTE: DOM access here // restores the original style properties after the offsets have been computed popperStyles.top = top; popperStyles.left = left; popperStyles[transformProp] = transform; options.boundaries = boundaries; const order = options.priority; let popper = data.offsets.popper; const check = { primary(placement) { let value = popper[placement]; if ( popper[placement] < boundaries[placement] && !options.escapeWithReference ) { value = Math.max(popper[placement], boundaries[placement]); } return { [placement]: value }; }, secondary(placement) { const mainSide = placement === 'right' ? 'left' : 'top'; let value = popper[mainSide]; if ( popper[placement] > boundaries[placement] && !options.escapeWithReference ) { value = Math.min( popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height) ); } return { [mainSide]: value }; }, }; order.forEach(placement => { const side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary'; popper = { ...popper, ...check[side](placement) }; }); data.offsets.popper = popper; return data; } ",
    "/** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function keepTogether(data) { const { popper, reference } = data.offsets; const placement = data.placement.split('-')[0]; const floor = Math.floor; const isVertical = ['top', 'bottom'].indexOf(placement) !== -1; const side = isVertical ? 'right' : 'bottom'; const opSide = isVertical ? 'left' : 'top'; const measurement = isVertical ? 'width' : 'height'; if (popper[side] < floor(reference[opSide])) { data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]; } if (popper[opSide] > floor(reference[side])) { data.offsets.popper[opSide] = floor(reference[side]); } return data; } ",
    "import getClientRect from '../utils/getClientRect'; import getOppositePlacement from '../utils/getOppositePlacement'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function inner(data) { const placement = data.placement; const basePlacement = placement.split('-')[0]; const { popper, reference } = data.offsets; const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1; const subtractLength = ['top', 'left'].indexOf(basePlacement) === -1; popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0); data.placement = getOppositePlacement(placement); data.offsets.popper = getClientRect(popper); return data; } ",
    "import isModifierRequired from '../utils/isModifierRequired'; import find from '../utils/find'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by update method * @argument {Object} options - Modifiers configuration and options * @returns {Object} The data object, properly modified */ export default function hide(data) { if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) { return data; } const refRect = data.offsets.reference; const bound = find( data.instance.modifiers, modifier => modifier.name === 'preventOverflow' ).boundaries; if ( refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left ) { // Avoid unnecessary DOM access if visibility hasn't changed if (data.hide === true) { return data; } data.hide = true; data.attributes['x-out-of-boundaries'] = ''; } else { // Avoid unnecessary DOM access if visibility hasn't changed if (data.hide === false) { return data; } data.hide = false; data.attributes['x-out-of-boundaries'] = false; } return data; } ",
    "import setStyles from '../utils/setStyles'; import setAttributes from '../utils/setAttributes'; import getReferenceOffsets from '../utils/getReferenceOffsets'; import computeAutoPlacement from '../utils/computeAutoPlacement'; /** * @function * @memberof Modifiers * @argument {Object} data - The data object generated by `update` method * @argument {Object} data.styles - List of style properties - values to apply to popper element * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element * @argument {Object} options - Modifiers configuration and options * @returns {Object} The same data object */ export default function applyStyle(data) { // any property present in `data.styles` will be applied to the popper, // in this way we can make the 3rd party modifiers add custom styles to it // Be aware, modifiers could override the properties defined in the previous // lines of this modifier! setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper, // they will be set as HTML attributes of the element setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties if (data.arrowElement && Object.keys(data.arrowStyles).length) { setStyles(data.arrowElement, data.arrowStyles); } return data; } /** * Set the x-placement attribute before everything else because it could be used * to add margins to the popper margins needs to be calculated to get the * correct popper offsets. * @method * @memberof Popper.modifiers * @param {HTMLElement} reference - The reference element used to position the popper * @param {HTMLElement} popper - The HTML element used as popper * @param {Object} options - Popper.js options */ export function applyStyleOnLoad( reference, popper, options, modifierOptions, state ) { // compute reference element offsets const referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object, // modifiers will be able to edit `placement` if needed // and refer to originalPlacement to know the original value const placement = computeAutoPlacement( options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding ); popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because // without the position applied we can't guarantee correct computations setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' }); return options; } "
    ],
    names: [
    "functionToCheck",
    "getType",
    "toString",
    "call",
    "element",
    "nodeType",
    "window",
    "ownerDocument",
    "defaultView",
    "css",
    "getComputedStyle",
    "property",
    "nodeName",
    "parentNode",
    "host",
    "document",
    "body",
    "getStyleComputedProperty",
    "overflow",
    "overflowX",
    "overflowY",
    "test",
    "getScrollParent",
    "getParentNode",
    "version",
    "isIE11",
    "documentElement",
    "noOffsetParent",
    "isIE",
    "offsetParent",
    "nextElementSibling",
    "indexOf",
    "getOffsetParent",
    "firstElementChild",
    "node",
    "getRoot",
    "element1",
    "element2",
    "order",
    "compareDocumentPosition",
    "Node",
    "DOCUMENT_POSITION_FOLLOWING",
    "start",
    "end",
    "range",
    "createRange",
    "setStart",
    "setEnd",
    "commonAncestorContainer",
    "contains",
    "isOffsetContainer",
    "element1root",
    "findCommonOffsetParent",
    "side",
    "upperSide",
    "html",
    "scrollingElement",
    "subtract",
    "scrollTop",
    "getScroll",
    "scrollLeft",
    "modifier",
    "top",
    "bottom",
    "left",
    "right",
    "sideA",
    "axis",
    "sideB",
    "parseFloat",
    "styles",
    "Math",
    "parseInt",
    "computedStyle",
    "getSize",
    "offsets",
    "width",
    "height",
    "rect",
    "getBoundingClientRect",
    "result",
    "sizes",
    "getWindowSizes",
    "clientWidth",
    "clientHeight",
    "horizScrollbar",
    "offsetWidth",
    "vertScrollbar",
    "offsetHeight",
    "getBordersSize",
    "getClientRect",
    "fixedPosition",
    "isIE10",
    "runIsIE",
    "isHTML",
    "parent",
    "childrenRect",
    "parentRect",
    "scrollParent",
    "borderTopWidth",
    "borderLeftWidth",
    "marginTop",
    "marginLeft",
    "includeScroll",
    "excludeScroll",
    "relativeOffset",
    "getOffsetRectRelativeToArbitraryNode",
    "innerWidth",
    "innerHeight",
    "offset",
    "isFixed",
    "parentElement",
    "el",
    "boundaries",
    "getFixedPositionOffsetParent",
    "boundariesElement",
    "getViewportOffsetRectRelativeToArtbitraryNode",
    "boundariesNode",
    "popper",
    "padding",
    "isPaddingNumber",
    "placement",
    "getBoundaries",
    "rects",
    "refRect",
    "sortedAreas",
    "Object",
    "keys",
    "map",
    "getArea",
    "sort",
    "b",
    "area",
    "a",
    "filteredAreas",
    "filter",
    "computedPlacement",
    "length",
    "key",
    "variation",
    "split",
    "commonOffsetParent",
    "x",
    "marginBottom",
    "y",
    "marginRight",
    "hash",
    "replace",
    "popperRect",
    "getOuterSizes",
    "popperOffsets",
    "isHoriz",
    "mainSide",
    "secondarySide",
    "measurement",
    "secondaryMeasurement",
    "referenceOffsets",
    "getOppositePlacement",
    "Array",
    "prototype",
    "find",
    "arr",
    "findIndex",
    "cur",
    "match",
    "obj",
    "modifiersToRun",
    "ends",
    "modifiers",
    "slice",
    "forEach",
    "warn",
    "fn",
    "enabled",
    "isFunction",
    "data",
    "reference",
    "state",
    "isDestroyed",
    "getReferenceOffsets",
    "options",
    "positionFixed",
    "computeAutoPlacement",
    "flip",
    "originalPlacement",
    "getPopperOffsets",
    "position",
    "runModifiers",
    "isCreated",
    "onUpdate",
    "onCreate",
    "some",
    "name",
    "prefixes",
    "upperProp",
    "charAt",
    "toUpperCase",
    "i",
    "prefix",
    "toCheck",
    "style",
    "isModifierEnabled",
    "removeAttribute",
    "willChange",
    "getSupportedPropertyName",
    "disableEventListeners",
    "removeOnDestroy",
    "removeChild",
    "isBody",
    "target",
    "addEventListener",
    "passive",
    "push",
    "updateBound",
    "scrollElement",
    "scrollParents",
    "eventsEnabled",
    "setupEventListeners",
    "scheduleUpdate",
    "removeEventListener",
    "removeEventListeners",
    "n",
    "isNaN",
    "isFinite",
    "unit",
    "isNumeric",
    "value",
    "attributes",
    "setAttribute",
    "round",
    "noRound",
    "referenceWidth",
    "popperWidth",
    "isVertical",
    "isVariation",
    "horizontalToInteger",
    "verticalToInteger",
    "bothOddWidth",
    "requesting",
    "isRequired",
    "requested",
    "counter",
    "index",
    "validPlacements",
    "concat",
    "reverse",
    "str",
    "size",
    "useHeight",
    "fragments",
    "frag",
    "trim",
    "divider",
    "search",
    "splitRegex",
    "ops",
    "mergeWithPrevious",
    "op",
    "reduce",
    "toValue",
    "index2",
    "basePlacement",
    "parseOffset",
    "min",
    "floor",
    "max",
    "timeoutDuration",
    "longerTimeoutBrowsers",
    "isBrowser",
    "navigator",
    "userAgent",
    "supportsMicroTasks",
    "Promise",
    "called",
    "resolve",
    "then",
    "scheduled",
    "MSInputMethodContext",
    "documentMode",
    "isFirefox",
    "placements",
    "BEHAVIORS",
    "Popper",
    "requestAnimationFrame",
    "update",
    "debounce",
    "bind",
    "Defaults",
    "jquery",
    "modifierOptions",
    "onLoad",
    "enableEventListeners",
    "destroy",
    "Utils",
    "global",
    "PopperUtils",
    "shiftvariation",
    "shiftOffsets",
    "instance",
    "transformProp",
    "popperStyles",
    "transform",
    "priority",
    "check",
    "escapeWithReference",
    "opSide",
    "isModifierRequired",
    "arrowElement",
    "querySelector",
    "len",
    "sideCapitalized",
    "toLowerCase",
    "altSide",
    "arrowElementSize",
    "center",
    "popperMarginSide",
    "popperBorderSide",
    "sideValue",
    "arrow",
    "flipped",
    "placementOpposite",
    "flipOrder",
    "behavior",
    "FLIP",
    "CLOCKWISE",
    "clockwise",
    "COUNTERCLOCKWISE",
    "refOffsets",
    "overlapsRef",
    "overflowsLeft",
    "overflowsRight",
    "overflowsTop",
    "overflowsBottom",
    "overflowsBoundaries",
    "flippedVariation",
    "flipVariations",
    "getOppositeVariation",
    "subtractLength",
    "bound",
    "hide",
    "legacyGpuAccelerationOption",
    "gpuAcceleration",
    "offsetParentRect",
    "getRoundedOffsets",
    "devicePixelRatio",
    "prefixedProperty",
    "invertTop",
    "invertLeft",
    "arrowStyles"
    ],
    mappings: "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"
    }